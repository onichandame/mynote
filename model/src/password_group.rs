//! SeaORM Entity. Generated by sea-orm-codegen 0.7.0

use async_recursion::async_recursion;
use sea_orm::{entity::prelude::*, ConnectionTrait, Set};
use serde::Deserialize;

use crate::error::Error;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize)]
#[serde(rename_all = "camelCase")]
#[sea_orm(table_name = "password_groups")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i32,
    pub uuid: String,
    pub lamport_clock: i32,
    pub created_at: DateTime,
    pub updated_at: Option<DateTime>,
    pub deleted_at: Option<DateTimeUtc>,

    pub user_id: i32,
    pub parent_id: Option<i32>,
    pub title: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "Entity",
        from = "Column::ParentId",
        to = "Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    SelfRef,
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::UserId",
        to = "super::user::Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    User,
    #[sea_orm(has_many = "super::password::Entity")]
    Passwords,
}

impl Related<super::user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl Related<super::password::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Passwords.def()
    }
}

impl ActiveModelBehavior for ActiveModel {
    fn before_save(mut self, insert: bool) -> Result<Self, DbErr> {
        if insert {
            self.lamport_clock = Set(0);
        } else {
            self.lamport_clock = Set(self.lamport_clock.take().ok_or(DbErr::Custom(
                "lamport clock not found before update".to_owned(),
            ))? + 1);
        }
        Ok(self)
    }
}

impl Model {
    // todo: check loop
    pub async fn has_ancestor<TDb: ConnectionTrait>(
        &self,
        ancestor: i32,
        db: &TDb,
    ) -> Result<bool, Error> {
        Ok(self._has_ancestor(ancestor, db, vec![]).await?)
    }

    #[async_recursion]
    async fn _has_ancestor<TDb: ConnectionTrait>(
        &self,
        ancestor: i32,
        db: &TDb,
        mut visited: Vec<i32>,
    ) -> Result<bool, Error> {
        match self.parent_id {
            Some(parent) => {
                if visited.contains(&self.id) {
                    Err(format!("password groups are looped at {}", self.id).into())
                } else if parent == ancestor {
                    Ok(true)
                } else {
                    visited.push(self.id);
                    Ok(Entity::find_by_id(parent)
                        .one(db)
                        .await?
                        .ok_or("parent not found")?
                        ._has_ancestor(ancestor, db, visited)
                        .await?)
                }
            }
            None => Ok(false),
        }
    }
}
